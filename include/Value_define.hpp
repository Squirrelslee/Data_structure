#pragma once
#include <iostream>
#include <utility>
#include <vector>

//左值、右值
void left_value()
{
    int b = 1, c = 1;//1作为普通字面量为右值，b、c为左值
    //int a = &(b + c);错误也不能放在等号左边
}
//左值：可以取地址并且有名字的东西就是左值；
//右值：不能取地址的没有名字的东西就是右值。
/*
左值一般有：
函数名和变量名
返回左值引用的函数调用
前置自增自减表达式++i、--i
由赋值表达式或赋值运算符连接的表达式(a=b, a += b等)
解引用表达式*p
*/

//纯右值、将亡值都属于右值
/*
//纯右值：元算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量lambda表达式等都是纯右值
除字符串字面值外的字面值
返回非引用类型的函数调用
后置自增自减表达式i++、i--
算术表达式(a+b, a*b, a&&b, a==b等)
取地址表达式等(&a)
*/

//将亡值
/*
将亡值是指C++11新增的和右值引用相关的表达式，通常指将要被移动的对象、T&&函数的返回值、
std::move函数的返回值、转换为T&&类型转换函数的返回值，将亡值可以理解为即将要销毁的值，
通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，
可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。
*/
void Dead_value()
{
    std::string str = "hello";
    std::vector<std::string> v;
    //调用常规的拷贝构造函数，新建字符数组，拷贝数据
    v.push_back(str);
    std::cout << "After copy, str is \"" << str << "\n";
    //调用移动构造函数，掏空str，掏空后，最好不要使用str
    v.push_back(std::move(str));
    std::cout << "After move, str is \"" << str << "\n";
    std::cout << "The contents of the vector are\"" << v[0]
                << "\",\"" << v[1] << "\"\n";
}
//左值引用

//右值引用

//移动语义

//返回优化