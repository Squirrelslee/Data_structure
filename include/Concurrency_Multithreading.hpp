/*
一、并发、进程、线程的基本概念和综述
（1.1）并发：一个程序同时执行多个独立的任务；提高性能
单核cpu某一时刻只能执行一个任务：由操作系统调度，每秒进行多次“任务切换”
这是并发的假象，这种切换（上下文切换）是有时间消耗的。比如切换时要保存切换前的各种状态，而切还回来要复原

多cpu：多核，能够实现真正的并行执行多个任务（硬件并发）

（1.2）可执行程序
//磁盘上的一个文件，一个扩展名为.exe;linux, ls -ls, rwxrwxrwx(x执行权限)

（1.3）进程：就是一个可执行程序运行起来了，就叫创建了一个进程。

（1.4）线程：每个进程，都有一个主线程，这个主线程是唯一的，也就是一个进程中只有一个主线程。
运行程序，实际上是进程的主线程来执行（调用）main函数中的代码。

除了主线程之外，我们可以通过自己写代码来创建其他线程，其他线程走的是别的道路。甚至去不同的地方，
我每创建一个新线程，就可以在同一时刻，多走一条不同的代码执行路径；

多线程（并发）
线程并不是越多越好，每一个线程，都需要一个独立的堆栈空间（1M），线程之间的切换要保存很多中间状态；
切换会耗费本该属于程序运行的时间。

a)线程是用来执行代码的；
b)把线程理解成一条代码执行的通路，一个新线程代表一条新的通路
c)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)
d)因为主线程是自动启动的，所以一个进程中最少有一个线程(主线程)。
e)多线程程序，可以同时执行多个事，所以运行效率高。但是到底有多高，并不是一个很容易评估和量化的东西。

(1.5)学习心得
开发多线程程序：实力的体现。一个是商用的必须需求；
线程开发有一定难度，实现代码更夫扎。理解上更难一些，需要一定的学习时间。

二、并发的实现方法
实现并发的手段：通过多个进程实现并发；在单独的进程中，我创建国歌线程来实现并发；自己写代码来创建除了主线程之外的其他线程；

（2.1）多进程并发
word启动、ie浏览器启动
账号服务器，游戏逻辑服务器。服务器进程之间的通信。
进程之间通信（同一个电脑上：管道，文件，消息队列，共享内存);
            (不同电脑上：socket通信技术)
(2.2)多线程并发：但个进程中，创建了多个线程：轻量级进程。每个线程都有自己独立的运行路径，但是一个进程中的所有线程共享地址空间(共享内存)
    全局变量，指针，引用都可以在线程之间传递，所以：使用多线程开小远远小于多进程。
    //共享内存带来新问题。数据一致性问题：线程A，线程B；

(2.3)总结
和进程比、线程如下优点：
线程启动速度更快，更轻量级；
系统资源开小更少，执行速度更快，比如共享内存这种通信方式比任何其他的通信方式都快；
缺点：
使用有一定难度，要小心处理数据的一致性问题。

三：C++11新标准线程库
以往：windows: CreateThread(), _beginthread(), _beginthredexe() 创建线程
Linux：pthread_create():创建线程

临界区,互斥量；
以往多线程代码不能跨平台;
POSIX thread(pthread);跨平台；做一番配置，所以同起来也不方便

从C++11新标准：C++语言本身增加对多线程的支持，意味着可移植性，大大减少了工作量



*/
#include <iostream>
#include <thread>
#include <vector>




void Multithreading_Test()
{
    std::cout << "my thread!" << std::endl;
    //主线程执行完毕了，但子线程没执行完毕会出错！！！！程序不稳定

    std::cout << "mu thread has runned!" << std::endl;
/*
整个进程是否执行完毕的标志是主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了；
此时。一般情况下：如果其他子线程还没执行完毕，那么这些子线程也会被操作系统强制终止。
所以，一般情况下，如果想保存子线程的运行状态，那么让主线程一直保持运行。
这条规律也有例外。
a)包含头文件thread
b)自己创建的线程也要从一个函数(初始函数)开始运行；
*/
    





}



